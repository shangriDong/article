**一、策略**
定义了算法组，分别封装起来，让他们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。


**OO原则**
封装变化
多用组合，少用继承
针对接口编程，不针对实现编程

**二、观察者模式**
定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。

**OO原则**
为了交互对象之间的松散耦合设计而努力

**三、装饰者模式**
动态地将责任附加到对象上。想要拓展功能，装饰者提供有别与继承的另一种选择。

**OO原则**
对拓展开放，对修改关闭

**四、工厂模式**
*抽象工厂模式*			提供一个接口用于常见相关或依赖对象的家族，而不需要明确指定具体类。
*工厂方法模式*			定义了一个常见对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。

**OO原则**
依赖抽象，不要依赖具体类

**五、单间模式**
确保一个类只有一个实例，并提供全局访问点。

**六、命令模式**
将请求封装成对象，这可以让你使用不同的请求、队列，或者日志请求来参数化其他对象。命令模式也可以支持撤销操作。

**七、适配器模式**
将一个类的接口，转换成客户期望另一个接口。适配器让原本不兼容的类可以合作无间。

**八、外观模式**
提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个工程接口，让子系统更容易使用。
1.被当做参数传进来的参数，其方法可以被调用。
2.可以跳用类组件的方法。
3.可以条用同一个对象内的本地方法。
4.可以调用你所创建或实例化得对象的方法。

**OO原则**

只和朋友交谈

**九、模板方法模式**
在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法是得自雷可以再不改变算法结构的情况下，重新定义算法中的某些步骤。

**OO原则**
别找我，我会找你
我们最新的原则提醒你，由超类控制一切，当他们需要的时候，自然回去调用子类，这就跟好莱坞一样。

**十、迭代器模式**
提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。

**十一、组合模式**
允许你将对象组成属性结构来表现“整体/部分”的层次接口。组合能让客户以一致的方法处理个别对象和对象组合。

**OO原则**
类应该只有一个改变的理由

**十二、状态模式**
允许对象在内部状态改变时改变他的行为，对象看起来好像修改了它的类。

**十三、代理模式**
为另一个对象提供一个替身或占位符以访问这个对象。

**十四、复合模式**
复合模式组合两个或以上的模式，组成一个解决方案，解决一再发生的一般性问题。
